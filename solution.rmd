# Run the tool

The tool computes a shortest solution.

The trace is expressed as `move_$dest_$src_$r`.
For instance `move_2_0_0` is move smallest ring (index 0) from pole 0 to pole 2.

The trace is expressed on the `work/` version of the moel, where parameters have been removed.

# Q1 Compare the two variants, explain how the two encodings differ.

## hanoi.gal

Hanoi uses one variable per ring.
The value of the variable gives the position of the ring : 0 for pole 0, 1 for pole 1...

We have N variables in an array, to represent the N rings.

The smallest ring has index 0, the largest ring has index N-1.

The move transition tries to move a ring with index $r from pole with index $src to a pole with index $dest such that :
* the ring with index $r must be in position $src
* $src and $dest should be different (useless otherwise)
* Then we test, for any other ring with index $o
  * if $o is smaller then the current ring $r, then it should not be on the pole $src or the pole $dest. The abort interrupts the treatment.
* If all conditions are met, we can update the position of the ring to be $dest

Initial situation is all rings at pole 0.

Goal situation is all rings at pole 2.

So total $N variables with domain {0,1,2}.

## hanoipoles.gal

Hanoi Poles uses one set of $N binary variables per pole (3 bitvectors of size $N).
The value of the variables tells which rings are on the pole. 

To declare these 3*$N variables, we use a single array with size 3*$N.
GAL currently do not support multi-dimensional arrays, but we can think of it as an array [3][$N]. 
The model uses arithmetic on indexes to simulate such an array.

Thus `tab[$i + $N * $pole]` should be read as `tab[$pole][$i]`.

The smallest ring on each pole has index 0, the largest ring has index N-1.

The init transition intializes the system by setting all the bits of pole with index 0 to 1.
These are indexes 0 to $N-1.
This init gadget is used to initialize the array in a parametric way (for loop).

The move transition tries to move a ring with index $r from pole with index $src to a pole with index $dest such that :
* the ring with index $r must be in position $src. This is testing that the $r bit of pole $src is set.
* $src and $dest should be different (useless otherwise)
* Then we test, for any other ring with index $o
  * if $o is smaller then the current ring $r, then it should not be on the pole $src or the pole $dest. These tests qre again testing if q bit is set. The abort interrupts the treatment.
* If all conditions are met, we can update the position of the ring to be $dest. This involves clearing the $r bit of $src and setting the bit $r of $dst

Initial situation is all bits of pole 1 set (and all other poles clear).

Goal situation is all bits of pole 2 set, i.e. indexes from 2*N to 3*N-1 (and all other bits clear).

So total 3*$N variables with domain {0,1} + one variable for the init gadget

## Do both models generate the same Kripke structure / State space ?

Almost but not quite, due to the gadget to intialize hanoipoles, it has one more state than the other version.
Atomic propositions have an equivalent but need to be transcoded.

Still overall, both models have the same state space for both states and transition relation.
The tool reports a difference of one in state space size, and the same shortest trace with "init" added at start.

# Q2 Evolution of $N

To modify $N in each model
* update the definition of $N
* update the goal property. This is a bit of a pain, since there is no parametric syntax for properties currently in GAL. Just copy paste and edit the target indexes.

We observe

Value of N | 1 | 2 | 3 | 4 | ... | N
---|---|---|---|---|---|---
Number of States | 3 | 9 | 27 | 81 | ...| 3^N
Shortest trace | 1 | 3 | 7 | 15 | ...| 2^N -1


