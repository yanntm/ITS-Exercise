# Run the tool

The tool computes a shortest solution.

The trace is expressed as `move_$dest_$src_$r`.
For instance `move_2_0_0` is move smallest ring (index 0) from pole 0 to pole 2.

The trace is expressed on the `work/` version of the moel, where parameters have been removed.

# Q1 Compare the two variants, explain how the two encodings differ.

## hanoi.gal

Hanoi uses one variable per ring.
The value of the variable gives the position of the ring : 0 for pole 0, 1 for pole 1...

We have N variables in an array, to represent the N rings.

The smallest ring has index 0, the largest ring has index N-1.

The move transition tries to move a ring with index $r from pole with index $src to a pole with index $dest such that :
* the ring with index $r must be in position $src
* $src and $dest should be different (useless otherwise)
* Then we test, for any other ring with index $o
  * if $o is smaller then the current ring $r, then it should not be on the pole $src or the pole $dest. The abort interrupts the treatment.
* If all conditions are met, we can update the position of the ring to be $dest

Initial situation is all rings at pole 0.

Goal situation is all rings at pole 2.

So total $N variables with domain {0,1,2}.

## hanoipoles.gal

Hanoi Poles uses one set of $N binary variables per pole (3 bitvectors of size $N).
The value of the variables tells which rings are on the pole. 

To declare these 3*$N variables, we use a single array with size 3*$N.
GAL currently do not support multi-dimensional arrays, but we can think of it as an array [3][$N]. 
The model uses arithmetic on indexes to simulate such an array.

Thus `tab[$i + $N * $pole]` should be read as `tab[$pole][$i]`.

The smallest ring on each pole has index 0, the largest ring has index N-1.

The init transition intializes the system by setting all the bits of pole with index 0 to 1.
These are indexes 0 to $N-1.
This init gadget is used to initialize the array in a parametric way (for loop).

The move transition tries to move a ring with index $r from pole with index $src to a pole with index $dest such that :
* the ring with index $r must be in position $src. This is testing that the $r bit of pole $src is set.
* $src and $dest should be different (useless otherwise)
* Then we test, for any other ring with index $o
  * if $o is smaller then the current ring $r, then it should not be on the pole $src or the pole $dest. These tests qre again testing if q bit is set. The abort interrupts the treatment.
* If all conditions are met, we can update the position of the ring to be $dest. This involves clearing the $r bit of $src and setting the bit $r of $dst

Initial situation is all bits of pole 1 set (and all other poles clear).

Goal situation is all bits of pole 2 set, i.e. indexes from 2*N to 3*N-1 (and all other bits clear).

So total 3*$N variables with domain {0,1} + one variable for the init gadget

## Do both models generate the same Kripke structure / State space ?

Almost but not quite, due to the gadget to intialize hanoipoles, it has one more state than the other version.
Atomic propositions have an equivalent but need to be transcoded.

Still overall, both models have the same state space for both states and transition relation.
The tool reports a difference of one in state space size, and the same shortest trace with "init" added at start.

# Q2 Evolution of $N

To modify $N in each model
* update the definition of $N
* update the goal property. This is a bit of a pain, since there is no parametric syntax for properties currently in GAL. Just copy paste and edit the target indexes.

We observe

Value of N | 1 | 2 | 3 | 4 | ... | N
---|---|---|---|---|---|---
Number of States | 3 | 9 | 27 | 81 | ...| 3^N
Shortest trace | 1 | 3 | 7 | 15 | ...| 2^N -1

The state space size, given that we have N variables with domain {0,1,2} indicates that all situations are reachable in fact.
So we could choose as goal any arbitrary position for each ring, and there would be a solution.

The shortest trace is consistent the recursive solution to hanoi; repeat twice what you did at previous step + one move to recurse.

Hypothesis: I can move N rings from pole a to pole b in K operations.
* N=1 is K=1 one move (trivial)
* N+1 : move all smaller rings from a to pole c in K, move current ring from a to pole b in 1, move all smaller rings from pole c to pole b in K. So 2K+1 moves.

## Step 3 : State space encoding

Observing the DD shows a very linear aspect for the state space of the ring model, because as already observed, all configurations are reachable. We ahve the full cartesian product of variable domains, which is a best case scenario for DD techniques. With N nodes (and 3 arcs per node, represented as a single arc with label 0..2) we reprent 3^N states.

The poles model is much larger; the ordering heuristic did not do a great job here. There is still quite a bit of sharing, at the bottom the tree merges again, but those long lines are copies of one another, but identified as different because they have different children, thus copied. Compression is good but not great.

Using BMC builds much larger structures in representation size (nodes in the DD) but with less states in them !
This leads to a "peak effect" that limits symbolic BFS approaches : before reaching the (small) solution DD, we go through potentially very large intermediate DD. 

Memory usage is hard to predict, but typically peaks at very high level with respect to final representation sizeat some intermediate steps. Saturation can avoid this effect.

Moving init variable at the top isolates a single path : the state where init is 0 and all bits are 0 too.
The rest of the state space is attached to init=1 decision path.

The order suggested in the hint will indeed be very effective, yielding similar runtimes and compression factors for both models.
Finding the optimal ordering for DD is an NP-Complete problem unfortunately, we have to rely on heuristics.


## Step 4 : Saturation

Yes, saturation rocks. 
This example is pathologically bad for BFS, simply because the shortest solution trace length is growing exponentially.
This means the number of iterations of the BFS exploration must also groz exponentially, dominating overall complexity.

With the appropriate order on "ring state" version, smaller rings are placed at bottom of the DD, near the terminal.
When doing saturation, we go from terminals up to the root. 
* So at variable 0 (the smallest ring), we discover it can move anywhere
* go up one level, we discover ring 1 can move anywhere, since the smaller ring could be anywhere. We resaturate ring 0 on the fly, and now both ring 0 and 1 could be anywhere.
* in a single pass over the DD we find the solution 

Reverse the order and saturation is broken
* the ring N cannot move in isolation
* ring N-1 cannot move etc...
* each move of a ring must to reach the root decision variable, ring 0, to be able to move

Saturation is sensitive to the top level impacted by each event, not just to the final state space representation (which is the same linear aspect for every order)

